" ================================================================
" THE HIDDEN REALM - Complete Smalltalk Implementation
" ================================================================
"
" This is a complete port of the text adventure game from Haskell to Smalltalk.
" The game is structured using object-oriented principles with a common base class
" and specialized implementations for each act.
"
" FILE STRUCTURE:
" ================================================================
"
" BaseGame.st      - Common game functionality (base class)
" Act1Game.st      - Act 1: Departure from the Edge of the World
" Act2Game.st      - Act 2: Descent into the Unknown  
" Act3Game.st      - Act 3: Into the Heart of the Unknown
" MainGame.st      - Main game runner and entry point
"
" HOW TO RUN:
" ================================================================
"
" 1. Load all files in order:
"    - BaseGame.st
"    - Act1Game.st
"    - Act2Game.st
"    - Act3Game.st
"    - MainGame.st
"
" 2. The MainGame.st file will automatically start the game when loaded
"
" 3. Alternatively, you can start manually with:
"    MainGame run
"
" GAME STRUCTURE:
" ================================================================
"
" BaseGame (abstract base class)
"   ├── Common command parsing
"   ├── Inventory management
"   ├── Task/state management
"   ├── Choice handling system
"   ├── Location and entity management
"   └── I/O utilities
"
" Act1Game extends BaseGame
"   ├── Antarctic base camp setting
"   ├── Supply gathering mechanics
"   ├── Fuel canister quest
"   └── Dialog with Clara
"
" Act2Game extends BaseGame
"   ├── Plane crash sequence
"   ├── Cave exploration
"   ├── Nazi wreck discovery
"   └── Injury/medical mechanics
"
" Act3Game extends BaseGame
"   ├── Hidden valley exploration
"   ├── Ancient creature encounter
"   ├── Nazi ambush scenarios
"   ├── Radio communication puzzle
"   └── Multiple ending paths
"
" KEY DESIGN PATTERNS:
" ================================================================
"
" 1. TEMPLATE METHOD PATTERN
"    BaseGame defines the overall structure, subclasses override specifics
"
" 2. STATE PATTERN
"    Game state managed through task flags and location tracking
"
" 3. COMMAND PATTERN
"    Input parsing and command execution separated
"
" 4. CHAIN OF RESPONSIBILITY
"    Command handling tries specialized handlers before defaults
"
" COMMON FUNCTIONALITY:
" ================================================================
"
" Entity Management:
"   - Entity class with type, name, description, takeability
"   - Location-based entity storage
"   - Inventory management with supply tracking
"
" Task System:
"   - String-based task flags for game state
"   - addTask:/removeTask:/hasTask: methods
"   - State-dependent behavior and hints
"
" Choice System:
"   - Standardized choice presentation and handling
"   - Context-specific choice processing
"   - Validation and error handling
"
" Command Processing:
"   - Unified command parsing
"   - Extensible command handling
"   - Special command support per act
"
" REUSABLE COMPONENTS:
" ================================================================
"
" The BaseGame class provides these reusable components:
"
" - parseCommand: - Standard text adventure command parsing
" - handleCommand: - Common command routing
" - waitForChoice: - Interactive choice handling
" - doInventory/doLook/doHint - Standard commands
" - Entity finding and manipulation
" - Supply counting and validation
" - Choice input validation
"
" EXTENSIBILITY:
" ================================================================
"
" To add new acts or modify existing ones:
"
" 1. Extend BaseGame
" 2. Override these key methods:
"    - setupLocations - Define locations and entities
"    - canMoveFrom:to: - Movement rules
"    - parseLocation: - Location name parsing
"    - descriptionOf: - Location descriptions
"    - getHint - Context-specific hints
"    - examineSpecial: - Special examination cases
"    - handleSpecialCommand: - Act-specific commands
"    - handleTake:/handleDrop:/handleUse: - Item interactions
"
" 3. Add dialog and choice handling as needed
"
" GAME FLOW:
" ================================================================
"
" MainGame -> Act1Game -> Act2Game -> Act3Game
"
" Each act:
" 1. Loads player state from previous act
" 2. Sets up its own locations and entities  
" 3. Runs main game loop until completion
" 4. Returns updated player state to next act
"
" Player state carries forward:
" - Inventory items
" - Supply selections (for act skipping)
"
" COMMANDS AVAILABLE:
" ================================================================
"
" Standard commands (all acts):
"   look, go <place>, examine <object>, talk <person>
"   take <object>, drop <object>, use <object>
"   inventory, hint, instructions, quit, next
"
" Special commands:
"   Act 1: Supply management, fuel quest
"   Act 2: 'go deeper', crash survival
"   Act 3: 'go woods/rock/tree', radio tuning
"
" Meta commands:
"   start - Begin from Act 1
"   act2 - Skip to Act 2 with supply selection
"   act3 - Skip to Act 3 with supply selection
"
" ================================================================

" Load and run the complete game:
" This file serves as documentation - the actual game is started
" by loading MainGame.st which calls MainGame run.

" To manually start:
" MainGame run.

" Example of extending the game with a new act:
"
" BaseGame subclass: Act4Game [
"     setupLocations [
"         " Define new locations and entities "
"         locations := Dictionary new.
"         " ... "
"         currentLocation := #'startLocation'
"     ]
"     
"     getHint [
"         " Provide contextual hints "
"         ^ 'Explore and discover!'
"     ]
"     
"     " Override other methods as needed "
" ]
"
" Then modify MainGame to include Act4Game in the sequence.

" ================================================================
" DEBUGGING AND DEVELOPMENT:
" ================================================================
"
" To debug game state:
"   game := Act1Game new.
"   game tasks inspect.
"   game inventory inspect.
"   game currentLocation inspect.
"
" To test specific scenarios:
"   game addTask: 'specific_task'.
"   game handleCommand: #(#go #'location').
"
" To examine game structure:
"   game locations keys inspect.
"   game locations at: #'location' inspect.
"
" ================================================================